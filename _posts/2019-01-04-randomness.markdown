---
layout: post
title:      "Randomness"
date:       2019-01-04 17:34:53 +0000
permalink:  randomness
---


For this blog, I really wanted to do some reading and interpreting of philosophical and mathematical significance of the concept of something being random and make a nice, healthy introduction to computer code - random.  Such a reading and research opened up a can of worms that fascinated me greatly.  I knew I would get stuck on that for days, so as to move forward with my learning process in software development, I will open with a couple well-rounded quotes and return to my in-depth introduction at a later time.

> From philosopher Eric Hoffer: “Creativity is the ability to introduce order into the randomness of nature.”

> From mathematician and computer scientist Robert R. Coveyou: “The generation of random numbers is too important to be left to chance.”

    -Quotes discovered at www.random.org/quotations

One of my first favorite topics and exercises in my Introduction to Computer Science class was producing a random number or series of random numbers by code and understanding its implications.  Computer science labs in randomness not only demonstrate the practicality of generating some random number simply for programming purposes.  Randomness in computer language also innately triggers a deeper thought process on the concept of random in life, mathematics and philosophy.  In order to explain this thought process further, I will reference C++ code I worked with in my Intro class and later to expand this fascination into Ruby language, I am currently learning, by exploring and reflecting on how random is accomplished in Ruby as well.

### C++ Random
     

In C++, `rand()`, is used to generate seemingly random numbers.  Below is the general code and result: 

|Code                                                           |
|---------------------------------------|
|![](https://i.imgur.com/aJrFodB.jpg)|

| Run 1                                                                 |Run 2                                                                  |
|-------------------------------------------|-------------------------------------------|
|![](https://i.imgur.com/tuOFLW6.jpg?1)|![](https://i.imgur.com/tuOFLW6.jpg?1)|

Overall, the numbers seem random on execution 1, however, running this executable program file again produces the exact same result, therefore this isn’t exactly what is thought of a random experience in life or statistics or what experiential definition one prefers. 

Alternatively, a different set of numbers can be generated by the use of `srand()` with a seed specifier in the syntax of `srand(somenumberyouwanthere)`:

|Code                                                           |
|---------------------------------------|
|![](https://i.imgur.com/Z28p5h6.jpg)|

However the result is a different series of numbers, running the program again has the same resulting numbers.

| Run 1                                                                 |Run 2                                                                  |
|-------------------------------------------|-------------------------------------------|
|![](https://i.imgur.com/G26RRcS.jpg?1)|![](https://i.imgur.com/G26RRcS.jpg?1)|


A do while loop in C++ using `rand()` can generate a different looking set of random numbers each time the user calls for it, but starting the program over again, generates the same set each time.  Note, `srand()` with a parameter could still be incorporated into this but would have the similar conundrum noted above. 

|Code                                                           |
|---------------------------------------|
|![](https://i.imgur.com/uklE5uM.jpg)|

**Run 1 and Run 2**
![](https://i.imgur.com/fFMlMwt.jpg?1)                                                 

Compilers are built on various logic and mathematical reasoning, so the interesting part is, at least for the moment in programming today, there is no true sense of random to a machine, a computer, a compiler, nor in computer language, and that is to say, no true sense of random in terms of its philosophical human experience.  So what needs to be done, at least in C++ to make patterns stop repeating?  What needs to happen so that the user can experience what they are used to calling random, even if just for that moment in time?

Noteworthy from the question above is that computer language can use exactly that, time.  In C++ to do so, `<ctime>` is an inclusion necessary in C++ files to utilize time functions.  From the `<ctime>` inclusion `time()` can be incorporated into the `srand()` setting the current time the program is executed, or the code is asked for, as the seed specifier and setting `time()` to `NULL`, 0, or nullptr depending on C++ version.

Once ctime is included `srand()` seed is set to `time()`, `time()` is set to `NULL`: 
`srand(time(NULL);` 

From here `rand()` is utilized once again for output as in the above examples, or of course whatever one’s program may call for.  The example below uses a combined version of all the techniques above to demonstrate the results of setting time as the `srand()` seed parameter. 

![](https://i.imgur.com/O6WEiB7.jpg)


| Run 1                                                               |Run 2                                                               | Run 3                                                               |
|------------------------------------------|------------------------------------------|------------------------------------------|
|![](https://i.imgur.com/nebsV1b.jpg?1)|![](https://i.imgur.com/g04Q0r7.jpg?1)|![](https://i.imgur.com/kloEnWM.jpg?1)|

Wouldn’t it be wonderful now, to go off on some tangent regarding physics having no concept of time beyond elapsed time for calculation?  That would be a lot of fun, but for now, I’ll have to move on to how random works in Ruby.

### Random Ruby

Of course, in ruby, there are methods on hand and ready to go simplifying the code involved.
The primary method involves the use of `#rand`.  Calling `rand` by itself yields a random float.  If a whole integer is desired typically `rand(1000)`, for example, will generate a random number between 0 and 1000. I tried to find a general maximum number available as in C++ but was unsuccessful so far.

|rand - no specification                       |float result                                                  |
|--------------------------------------|----------------------------------------|
|![](https://i.imgur.com/q2jf4gv.jpg)|![](https://i.imgur.com/pDlwa3u.jpg)|

|rand - with integer range                   |integer result                                             |
|--------------------------------------|----------------------------------------|
|![](https://i.imgur.com/yHfAvla.jpg)|![](https://i.imgur.com/Himv9Kd.jpg)|

In contrast to C++, Ruby `rand` methods are already setup to refer to a timestamp along with “the process id, and a sequence number” (ruby-doc.org).  In order to get a series of 10 random numbers, for now between 0 and 1000, and not repeat each time the program is started or method is called again, `rand(1000`) is sufficient in a while loop: 

|rand in a loop and called twice        |result - different numbers                    |
|----------------------------------- ---|----------------------------------------|
|![](https://i.imgur.com/BE3qlJr.jpg)|![](https://i.imgur.com/wPj6uuJ.jpg) |


Similar to C++, `srand(somenumberhere)`, will cause a reapeat of the same series each time a program is started or method is called once again.  So, in Ruby, in particular, `srand()` is helpful if one would like to repeat the same values by some seed.

|srand used with parameter                  |result  - same numbers                         |
|----------------------------------------|----------------------------------------|
|![](https://i.imgur.com/9TC1hZE.jpg)|![](https://i.imgur.com/JgYTTYu.jpg)|


I enjoy the C++ version slightly better as you can see exactly how that code is taking place and manipulating the values, why C++ is my favorite language all around, however.  C++ brings out the philosophical nature a little more by an innate sense of questioning.  I do enjoy the fact that the Ruby version is very simplistic and less exhausting to write, also why I have enjoyed Ruby overall. I suppose either language is sufficient and may just depend on the project or end result.  I think, at this concluding moment, the quotes I chose are perfect for the ideas at work within this post.

**Works Cited **

Britt, James and Neurogami. “Random” Ruby-doc.org. https://ruby-doc.org/core-2.2.0/Random.html


RANDOM.ORG. https://www.random.org/quotations/

